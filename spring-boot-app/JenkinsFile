pipeline {
  agent any
  tools {
    maven 'maven'
  }
  environment {
    SLACK_CHANNEL = '#devops'
    ENABLE_SLACK = 'true'
    DOCKER_IMAGE = "khaledhawil/java-cicd:${BUILD_NUMBER}"
    GIT_REPO_NAME = "Java-app-CI-CD-with-GitOps"
    GIT_USER_NAME = "khaledhawil"
    SONAR_URL = "http://sonarqube:9000"
    // Trivy configuration
    TRIVY_NO_PROGRESS = "true"
    TRIVY_CACHE_DIR = "/tmp/trivy-cache"
  }
  
  stages {
    stage('Pipeline Started') {
      steps {
        script {
          echo "ðŸš€ =============================================="
          echo "ðŸš€ Starting CI/CD Pipeline for ${JOB_NAME} #${BUILD_NUMBER}"
          echo "ðŸš€ Repository: ${env.GIT_REPO_NAME}"
          echo "ðŸš€ Branch: master"
          echo "ðŸš€ Build URL: ${BUILD_URL}"
          echo "ðŸš€ =============================================="
          
          sendSlackNotification('good', ":jenkins: *Pipeline Started* :rocket:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Branch:* master\n*Started by:* admin\n*Build URL:* ${BUILD_URL}")
        }
      }
    }
    
    stage('Checkout') {
      steps {
        echo "âœ… Repository already checked out by Jenkins"
      }
    }
    
    stage('Build and Test') {
      steps {
        sh 'ls -ltr'
        sh 'cd spring-boot-app && mvn clean package'
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *Build and Test Completed* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* SUCCESS :tada:\n*Artifact:* spring-boot-web.jar created\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Build and Test Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Static Code Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonarqube', variable: 'SONAR_AUTH_TOKEN')]) {
          sh 'cd spring-boot-app && mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=${SONAR_URL}'
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *SonarQube Analysis Completed* :chart_with_upwards_trend:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* SUCCESS :tada:\n*SonarQube Dashboard:* ${SONAR_URL}/dashboard?id=com.abhishek%3Aspring-boot-demo\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *SonarQube Analysis Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Build Docker Image') {
      steps {
        script {
          sh 'cd spring-boot-app && docker build -t ${DOCKER_IMAGE} .'
          echo "âœ… Docker image built successfully: ${DOCKER_IMAGE}"
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":docker: *Docker Image Built Successfully* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Image Build Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Security Scan with Trivy') {
      steps {
        script {          
          // Update Trivy database
          sh 'trivy --version && trivy image --download-db-only'
          
          // Scan the Docker image with improved timeout and error handling
          sh """
            echo "ðŸ” =============================================="
            echo "ðŸ” Starting Trivy Security Scan"
            echo "ðŸ” Image: ${DOCKER_IMAGE}"
            echo "ðŸ” =============================================="
            
            # Create reports directory
            mkdir -p trivy-reports

            # Run Trivy scan with increased timeout
            echo "ðŸ” Running detailed security scan (this may take a few minutes)..."
            trivy image --timeout 15m --scanners vuln --format json --output trivy-reports/trivy-report.json ${DOCKER_IMAGE} || echo "âš ï¸ JSON scan encountered issues but continuing..."
            
            # Generate table report with shorter timeout  
            trivy image --timeout 5m --scanners vuln --format table --output trivy-reports/trivy-report.txt ${DOCKER_IMAGE} || echo "âš ï¸ Table report timed out, using JSON report only"
            
            # Display scan results
            echo ""
            echo "ðŸ“Š TRIVY SECURITY SCAN RESULTS:"
            echo "=============================================="
            
            if [ -f "trivy-reports/trivy-report.txt" ] && [ -s "trivy-reports/trivy-report.txt" ]; then
              echo "âœ… Displaying first 30 lines of scan results:"
              head -30 trivy-reports/trivy-report.txt
              echo ""
              echo "(Report truncated for display - full report in Jenkins artifacts)"
            else
              echo "âš ï¸ Table report not available, checking JSON report status..."
              if [ -f "trivy-reports/trivy-report.json" ]; then
                echo "âœ… JSON report generated - vulnerabilities will be counted"
              else
                echo "âŒ No scan reports generated successfully"
              fi
            fi
            echo "=============================================="
            
            # Count vulnerabilities with fallback methods
            CRITICAL_VULNS=0
            HIGH_VULNS=0
            
            if command -v jq >/dev/null 2>&1 && [ -f "trivy-reports/trivy-report.json" ]; then
              echo "ðŸ” Analyzing vulnerabilities with jq..."
              CRITICAL_VULNS=\$(jq -r 'if .Results then [.Results[]?.Vulnerabilities[]? // empty] | map(select(.Severity == "CRITICAL")) | length else 0 end' trivy-reports/trivy-report.json 2>/dev/null || echo "0")
              HIGH_VULNS=\$(jq -r 'if .Results then [.Results[]?.Vulnerabilities[]? // empty] | map(select(.Severity == "HIGH")) | length else 0 end' trivy-reports/trivy-report.json 2>/dev/null || echo "0")
            else
              echo "ðŸ” Using grep-based counting (fallback method)..."
              if [ -f "trivy-reports/trivy-report.txt" ]; then
                CRITICAL_VULNS=\$(grep -c "CRITICAL" trivy-reports/trivy-report.txt 2>/dev/null || echo "0")
                HIGH_VULNS=\$(grep -c "HIGH" trivy-reports/trivy-report.txt 2>/dev/null || echo "0")
              fi
            fi
            
            echo ""
            echo "ðŸ“ˆ VULNERABILITY SUMMARY:"
            echo "Critical: \$CRITICAL_VULNS"
            echo "High: \$HIGH_VULNS"
            echo "Status: \$([ \$CRITICAL_VULNS -eq 0 ] && echo 'âœ… No Critical Issues' || echo 'âš ï¸ Review Required')"
            echo ""
            
            # Store counts for post actions
            echo \$CRITICAL_VULNS > trivy-reports/critical-count.txt
            echo \$HIGH_VULNS > trivy-reports/high-count.txt
            
            # Create summary report
            echo "Creating scan summary..."
            cat > trivy-reports/summary.txt << 'EOL'
Trivy Security Scan Summary
===========================
EOL
            echo "Image: ${DOCKER_IMAGE}" >> trivy-reports/summary.txt
            echo "Scan Date: \$(date)" >> trivy-reports/summary.txt
            echo "Critical Vulnerabilities: \$CRITICAL_VULNS" >> trivy-reports/summary.txt
            echo "High Vulnerabilities: \$HIGH_VULNS" >> trivy-reports/summary.txt
            echo "Status: \$([ \$CRITICAL_VULNS -eq 0 ] && echo 'PASSED âœ…' || echo 'REVIEW REQUIRED âš ï¸')" >> trivy-reports/summary.txt
            
            echo ""
            echo "ðŸ“‹ SCAN SUMMARY:"
            cat trivy-reports/summary.txt
          """
        }
      }
      post {
        always {
          // Archive the Trivy reports
          archiveArtifacts artifacts: 'trivy-reports/*', allowEmptyArchive: true
        }
        success {
          script {
            def criticalCount = readFile('trivy-reports/critical-count.txt').trim()
            def highCount = readFile('trivy-reports/high-count.txt').trim()
            
            // Determine security status and appropriate color
            def securityColor = 'good'
            def securityStatus = ':white_check_mark: SECURE'
            def securityIcon = ':shield:'
            def actionRequired = ''
            
            if (criticalCount.toInteger() > 0) {
              securityColor = 'danger'
              securityStatus = ':rotating_light: CRITICAL VULNERABILITIES FOUND'
              securityIcon = ':warning:'
              actionRequired = '\n:exclamation: *IMMEDIATE ACTION REQUIRED*\n:point_right: Review critical vulnerabilities before production deployment'
            } else if (highCount.toInteger() > 0) {
              securityColor = 'warning'
              securityStatus = ':yellow_circle: HIGH VULNERABILITIES DETECTED'
              securityIcon = ':mag:'
              actionRequired = '\n:warning: *REVIEW RECOMMENDED*\n:point_right: Consider updating dependencies to fix high-severity issues'
            }
            
            def vulnerabilitySummary = ''
            if (criticalCount.toInteger() > 0 || highCount.toInteger() > 0) {
              vulnerabilitySummary = "\n\n:bar_chart: *Vulnerability Breakdown:*"
              if (criticalCount.toInteger() > 0) {
                vulnerabilitySummary += "\n:red_circle: Critical: ${criticalCount}"
              }
              if (highCount.toInteger() > 0) {
                vulnerabilitySummary += "\n:orange_circle: High: ${highCount}"
              }
              vulnerabilitySummary += "\n:blue_circle: Medium & Low: Additional issues detected"
              vulnerabilitySummary += "\n\n:clipboard: *Full Report:* ${BUILD_URL}artifact/trivy-reports/"
            }
            
            sendSlackNotification(securityColor, "${securityIcon} *Trivy Security Scan Complete* ${securityIcon}\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Image:* ${DOCKER_IMAGE}\n*Status:* ${securityStatus}${vulnerabilitySummary}${actionRequired}\n\n:link: *Build Details:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Trivy Security Scan Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Image:* ${DOCKER_IMAGE}\n*Status:* SCAN FAILED :red_circle:\n*Issue:* Security scanning could not complete\n:point_right: Check Jenkins logs for scan errors\n\n:link: *Console:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Push Docker Image') {
      environment {
        REGISTRY_CREDENTIALS = credentials('docker-hub')
      }
      steps {
        script {
          sh 'echo $REGISTRY_CREDENTIALS_PSW | docker login -u $REGISTRY_CREDENTIALS_USR --password-stdin'
          sh 'docker push ${DOCKER_IMAGE}'
          echo "âœ… Docker image pushed successfully to Docker Hub"
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":rocket: *Docker Image Pushed Successfully* :ship:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Push Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Registry:* Docker Hub\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Push Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Push Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Update Deployment File') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'github', passwordVariable: 'GITHUB_TOKEN', usernameVariable: 'GITHUB_USERNAME')]) {
          sh '''
            git config user.email "khaledJenkins@gmail.com"
            git config user.name "Jenkins-user"
            git checkout master
            BUILD_NUMBER=${BUILD_NUMBER}
            sed -i "s/replaceImageTag/${BUILD_NUMBER}/g" spring-boot-app-manifests/deployment.yml
            
            if ! git diff --quiet spring-boot-app-manifests/deployment.yml; then
              git add spring-boot-app-manifests/deployment.yml
              git commit -m "Update deployment image to version ${BUILD_NUMBER}"
              git push https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:master
              echo "âœ… Deployment file updated and pushed to GitHub"
            else
              echo "â„¹ï¸ No changes to commit - deployment file already up to date"
            fi
          '''
        }
      }
    }
  }
  
  post {
    success {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "ðŸŽ‰ =============================================="
        echo "ðŸŽ‰ PIPELINE COMPLETED SUCCESSFULLY!"
        echo "ðŸŽ‰ Job: ${JOB_NAME}"
        echo "ðŸŽ‰ Build: #${BUILD_NUMBER}" 
        echo "ðŸŽ‰ Duration: ${duration}"
        echo "ðŸŽ‰ Docker Image: ${DOCKER_IMAGE}"
        echo "ðŸŽ‰ Deployment: Updated to version ${BUILD_NUMBER}"
        echo "ðŸŽ‰ Build URL: ${BUILD_URL}"
        echo "ðŸŽ‰ Console: ${BUILD_URL}console"
        echo "ðŸŽ‰ =============================================="
        
        sendSlackNotification('good', ":jenkins: *Pipeline Completed Successfully* :tada:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* SUCCESS :white_check_mark:\n*Duration:* ${duration}\n*Docker Image:* ${DOCKER_IMAGE}\n*Deployment:* Updated to version ${BUILD_NUMBER}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    failure {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "âŒ =============================================="
        echo "âŒ PIPELINE FAILED!"
        echo "âŒ Job: ${JOB_NAME}"
        echo "âŒ Build: #${BUILD_NUMBER}"
        echo "âŒ Duration: ${duration}"
        echo "âŒ Failed Stage: ${env.STAGE_NAME ?: 'Unknown'}"
        echo "âŒ Build URL: ${BUILD_URL}"
        echo "âŒ Console: ${BUILD_URL}console"
        echo "âŒ Please check the logs for more details"
        echo "âŒ =============================================="
        
        sendSlackNotification('danger', ":jenkins: *Pipeline Failed* :x:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* FAILED :red_circle:\n*Duration:* ${duration}\n*Failed Stage:* ${env.STAGE_NAME ?: 'Unknown'}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console\n*Please check the logs for more details* :point_up:")
      }
    }
    unstable {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Unstable* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* UNSTABLE :yellow_circle:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    aborted {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Aborted* :stop_sign:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* ABORTED :octagonal_sign:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
  }
}

// BULLETPROOF Slack notification function
def sendSlackNotification(String color, String message) {
  if (env.ENABLE_SLACK != 'true') {
    echo "ðŸ“ Slack disabled. Message: ${message}"
    return
  }
  
  echo "ðŸ“§ Sending Slack notification to ${env.SLACK_CHANNEL}..."
  
  // Method 1: Try Jenkins global Slack configuration
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message
    )
    echo "âœ… SUCCESS: Slack sent via global configuration"
    return
  } catch (Exception e1) {
    echo "âš ï¸ Method 1 failed: ${e1.getMessage()}"
  }
  
  // Method 2: Try with team domain
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message,
      teamDomain: 'work'
    )
    echo "âœ… SUCCESS: Slack sent via team domain"
    return
  } catch (Exception e2) {
    echo "âš ï¸ Method 2 failed: ${e2.getMessage()}"
  }
  
  // Method 3: Try webhook approach (if configured)
  try {
    sh """
      curl -X POST -H 'Content-type: application/json' \
      --data '{"channel":"${env.SLACK_CHANNEL}","text":"${message}","username":"Jenkins","icon_emoji":":jenkins:"}' \
      \${SLACK_WEBHOOK_URL:-"https://hooks.slack.com/services/YOUR/WEBHOOK/URL"}
    """
    echo "âœ… SUCCESS: Slack sent via webhook"
    return
  } catch (Exception e3) {
    echo "âš ï¸ Method 3 failed: ${e3.getMessage()}"
  }
  
  // Fallback: Beautiful console display
  echo ""
  echo "ðŸ“§ =============== SLACK NOTIFICATION ==============="
  echo "ðŸ“§ Channel: ${env.SLACK_CHANNEL} (work.slack.com)"
  echo "ðŸ“§ Status: ${color == 'good' ? 'SUCCESS âœ…' : color == 'danger' ? 'FAILED âŒ' : 'INFO â„¹ï¸'}"
  echo "ðŸ“§ Message:"
  message.split('\n').each { line ->
    echo "ðŸ“§   ${line}"
  }
  echo "ðŸ“§ ================================================="
  echo "ðŸ’¡ To enable actual Slack notifications:"
  echo "ðŸ’¡ 1. Configure Slack in Jenkins Global Settings"
  echo "ðŸ’¡ 2. Or set SLACK_WEBHOOK_URL environment variable"
  echo "ðŸ’¡ 3. Verify Jenkins has 'Slack Notification' plugin installed"
  echo ""
}
