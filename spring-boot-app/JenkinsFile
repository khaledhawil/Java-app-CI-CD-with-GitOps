pipeline {
  agent any
  tools {
    maven 'maven'
  }
  environment {
    SLACK_CHANNEL = '#devops'
    ENABLE_SLACK = 'true'
    DOCKER_IMAGE = "khaledhawil/java-cicd:${BUILD_NUMBER}"
    GIT_REPO_NAME = "Java-app-CI-CD-with-GitOps"
    GIT_USER_NAME = "khaledhawil"
    SONAR_URL = "http://sonarqube:9000"
    // Trivy configuration
    TRIVY_NO_PROGRESS = "true"
    TRIVY_CACHE_DIR = "/tmp/trivy-cache"
  }
  
  stages {
    stage('Pipeline Started') {
      steps {
        script {
          echo "ðŸš€ =============================================="
          echo "ðŸš€ Starting CI/CD Pipeline for ${JOB_NAME} #${BUILD_NUMBER}"
          echo "ðŸš€ Repository: ${env.GIT_REPO_NAME}"
          echo "ðŸš€ Branch: master"
          echo "ðŸš€ Build URL: ${BUILD_URL}"
          echo "ðŸš€ =============================================="
          
          sendSlackNotification('good', ":jenkins: *Pipeline Started* :rocket:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Branch:* master\n*Started by:* admin\n*Build URL:* ${BUILD_URL}")
        }
      }
    }
    
    stage('Checkout') {
      steps {
        echo "âœ… Repository already checked out by Jenkins"
      }
    }
    
    stage('Build and Test') {
      steps {
        sh 'ls -ltr'
        sh 'cd spring-boot-app && mvn clean package'
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *Build and Test Completed* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* SUCCESS :tada:\n*Artifact:* spring-boot-web.jar created\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Build and Test Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Static Code Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonarqube', variable: 'SONAR_AUTH_TOKEN')]) {
          sh 'cd spring-boot-app && mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=${SONAR_URL}'
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *SonarQube Analysis Completed* :chart_with_upwards_trend:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* SUCCESS :tada:\n*SonarQube Dashboard:* ${SONAR_URL}/dashboard?id=com.abhishek%3Aspring-boot-demo\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *SonarQube Analysis Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Build Docker Image') {
      steps {
        script {
          sh 'cd spring-boot-app && docker build -t ${DOCKER_IMAGE} .'
          echo "âœ… Docker image built successfully: ${DOCKER_IMAGE}"
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":docker: *Docker Image Built Successfully* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Image Build Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Security Scan with Trivy') {
      steps {
        script {
          // Install Trivy if not already installed
          sh '''
            # Check if Trivy is installed, if not install it
            if ! command -v trivy &> /dev/null; then
              echo "ðŸ“¦ Installing Trivy..."
              # Install Trivy for Ubuntu/Debian
              sudo apt-get update
              sudo apt-get install -y wget apt-transport-https gnupg lsb-release
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install -y trivy
            else
              echo "âœ… Trivy is already installed"
            fi
          '''
          
          // Update Trivy database
          sh 'trivy --version && trivy image --download-db-only'
          
          // Scan the Docker image
          sh """
            echo "ðŸ” =============================================="
            echo "ðŸ” Starting Trivy Security Scan"
            echo "ðŸ” Image: ${DOCKER_IMAGE}"
            echo "ðŸ” =============================================="
            
            # Create reports directory
            mkdir -p trivy-reports
            
            # Run Trivy scan with multiple output formats
            trivy image --format table --output trivy-reports/trivy-report.txt ${DOCKER_IMAGE} || true
            trivy image --format json --output trivy-reports/trivy-report.json ${DOCKER_IMAGE} || true
            
            # Display scan results
            echo ""
            echo "ðŸ“Š TRIVY SECURITY SCAN RESULTS:"
            echo "=============================================="
            cat trivy-reports/trivy-report.txt || echo "âš ï¸ Could not display report"
            echo "=============================================="
            
            # Check for HIGH and CRITICAL vulnerabilities
            HIGH_VULNS=\$(trivy image --format json ${DOCKER_IMAGE} | jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "HIGH" or .Severity == "CRITICAL") | .VulnerabilityID' | wc -l)
            CRITICAL_VULNS=\$(trivy image --format json ${DOCKER_IMAGE} | jq -r '.Results[]?.Vulnerabilities[]? | select(.Severity == "CRITICAL") | .VulnerabilityID' | wc -l)
            
            echo ""
            echo "ðŸ“ˆ VULNERABILITY SUMMARY:"
            echo "Critical: \$CRITICAL_VULNS"
            echo "High: \$HIGH_VULNS"
            echo ""
            
            # Store counts in environment variables for post actions
            echo \$CRITICAL_VULNS > trivy-reports/critical-count.txt
            echo \$HIGH_VULNS > trivy-reports/high-count.txt
          """
        }
      }
      post {
        always {
          // Archive the Trivy reports
          archiveArtifacts artifacts: 'trivy-reports/*', allowEmptyArchive: true
        }
        success {
          script {
            def criticalCount = readFile('trivy-reports/critical-count.txt').trim()
            def highCount = readFile('trivy-reports/high-count.txt').trim()
            
            sendSlackNotification('good', ":shield: *Security Scan Completed* :mag_right:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Trivy Security Scan\n*Status:* SUCCESS :white_check_mark:\n*Image:* ${DOCKER_IMAGE}\n*Critical Vulnerabilities:* ${criticalCount}\n*High Vulnerabilities:* ${highCount}\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Security Scan Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Trivy Security Scan\n*Status:* FAILED :x:\n*Image:* ${DOCKER_IMAGE}\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Push Docker Image') {
      environment {
        REGISTRY_CREDENTIALS = credentials('docker-hub')
      }
      steps {
        script {
          sh 'echo $REGISTRY_CREDENTIALS_PSW | docker login -u $REGISTRY_CREDENTIALS_USR --password-stdin'
          sh 'docker push ${DOCKER_IMAGE}'
          echo "âœ… Docker image pushed successfully to Docker Hub"
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":rocket: *Docker Image Pushed Successfully* :ship:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Push Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Registry:* Docker Hub\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Push Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Push Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Update Deployment File') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'github', passwordVariable: 'GITHUB_TOKEN', usernameVariable: 'GITHUB_USERNAME')]) {
          sh '''
            git config user.email "khaledJenkins@gmail.com"
            git config user.name "Jenkins-user"
            git checkout master
            BUILD_NUMBER=${BUILD_NUMBER}
            sed -i "s/replaceImageTag/${BUILD_NUMBER}/g" spring-boot-app-manifests/deployment.yml
            
            if ! git diff --quiet spring-boot-app-manifests/deployment.yml; then
              git add spring-boot-app-manifests/deployment.yml
              git commit -m "Update deployment image to version ${BUILD_NUMBER}"
              git push https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:master
              echo "âœ… Deployment file updated and pushed to GitHub"
            else
              echo "â„¹ï¸ No changes to commit - deployment file already up to date"
            fi
          '''
        }
      }
    }
  }
  
  post {
    success {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "ðŸŽ‰ =============================================="
        echo "ðŸŽ‰ PIPELINE COMPLETED SUCCESSFULLY!"
        echo "ðŸŽ‰ Job: ${JOB_NAME}"
        echo "ðŸŽ‰ Build: #${BUILD_NUMBER}" 
        echo "ðŸŽ‰ Duration: ${duration}"
        echo "ðŸŽ‰ Docker Image: ${DOCKER_IMAGE}"
        echo "ðŸŽ‰ Deployment: Updated to version ${BUILD_NUMBER}"
        echo "ðŸŽ‰ Build URL: ${BUILD_URL}"
        echo "ðŸŽ‰ Console: ${BUILD_URL}console"
        echo "ðŸŽ‰ =============================================="
        
        sendSlackNotification('good', ":jenkins: *Pipeline Completed Successfully* :tada:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* SUCCESS :white_check_mark:\n*Duration:* ${duration}\n*Docker Image:* ${DOCKER_IMAGE}\n*Deployment:* Updated to version ${BUILD_NUMBER}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    failure {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "âŒ =============================================="
        echo "âŒ PIPELINE FAILED!"
        echo "âŒ Job: ${JOB_NAME}"
        echo "âŒ Build: #${BUILD_NUMBER}"
        echo "âŒ Duration: ${duration}"
        echo "âŒ Failed Stage: ${env.STAGE_NAME ?: 'Unknown'}"
        echo "âŒ Build URL: ${BUILD_URL}"
        echo "âŒ Console: ${BUILD_URL}console"
        echo "âŒ Please check the logs for more details"
        echo "âŒ =============================================="
        
        sendSlackNotification('danger', ":jenkins: *Pipeline Failed* :x:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* FAILED :red_circle:\n*Duration:* ${duration}\n*Failed Stage:* ${env.STAGE_NAME ?: 'Unknown'}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console\n*Please check the logs for more details* :point_up:")
      }
    }
    unstable {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Unstable* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* UNSTABLE :yellow_circle:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    aborted {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Aborted* :stop_sign:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* ABORTED :octagonal_sign:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
  }
}

// BULLETPROOF Slack notification function
def sendSlackNotification(String color, String message) {
  if (env.ENABLE_SLACK != 'true') {
    echo "ðŸ“ Slack disabled. Message: ${message}"
    return
  }
  
  echo "ðŸ“§ Sending Slack notification to ${env.SLACK_CHANNEL}..."
  
  // Method 1: Try Jenkins global Slack configuration
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message
    )
    echo "âœ… SUCCESS: Slack sent via global configuration"
    return
  } catch (Exception e1) {
    echo "âš ï¸ Method 1 failed: ${e1.getMessage()}"
  }
  
  // Method 2: Try with team domain
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message,
      teamDomain: 'work'
    )
    echo "âœ… SUCCESS: Slack sent via team domain"
    return
  } catch (Exception e2) {
    echo "âš ï¸ Method 2 failed: ${e2.getMessage()}"
  }
  
  // Method 3: Try webhook approach (if configured)
  try {
    sh """
      curl -X POST -H 'Content-type: application/json' \
      --data '{"channel":"${env.SLACK_CHANNEL}","text":"${message}","username":"Jenkins","icon_emoji":":jenkins:"}' \
      \${SLACK_WEBHOOK_URL:-"https://hooks.slack.com/services/YOUR/WEBHOOK/URL"}
    """
    echo "âœ… SUCCESS: Slack sent via webhook"
    return
  } catch (Exception e3) {
    echo "âš ï¸ Method 3 failed: ${e3.getMessage()}"
  }
  
  // Fallback: Beautiful console display
  echo ""
  echo "ðŸ“§ =============== SLACK NOTIFICATION ==============="
  echo "ðŸ“§ Channel: ${env.SLACK_CHANNEL} (work.slack.com)"
  echo "ðŸ“§ Status: ${color == 'good' ? 'SUCCESS âœ…' : color == 'danger' ? 'FAILED âŒ' : 'INFO â„¹ï¸'}"
  echo "ðŸ“§ Message:"
  message.split('\n').each { line ->
    echo "ðŸ“§   ${line}"
  }
  echo "ðŸ“§ ================================================="
  echo "ðŸ’¡ To enable actual Slack notifications:"
  echo "ðŸ’¡ 1. Configure Slack in Jenkins Global Settings"
  echo "ðŸ’¡ 2. Or set SLACK_WEBHOOK_URL environment variable"
  echo "ðŸ’¡ 3. Verify Jenkins has 'Slack Notification' plugin installed"
  echo ""
}
