pipeline {
  agent any
  tools {
    maven 'maven'
  }
  environment {
    SLACK_CHANNEL = '#devops'
    ENABLE_SLACK = 'true'
    DOCKER_IMAGE = "khaledhawil/java-cicd:${BUILD_NUMBER}"
    GIT_REPO_NAME = "Java-app-CI-CD-with-GitOps"
    GIT_USER_NAME = "khaledhawil"
    SONAR_URL = "http://sonarqube:9000"
  }
  
  stages {
    stage('Pipeline Started') {
      steps {
        script {
          echo "🚀 =============================================="
          echo "🚀 Starting CI/CD Pipeline for ${JOB_NAME} #${BUILD_NUMBER}"
          echo "🚀 Repository: ${env.GIT_REPO_NAME}"
          echo "🚀 Branch: master"
          echo "🚀 Build URL: ${BUILD_URL}"
          echo "🚀 =============================================="
          
          sendSlackNotification('good', ":jenkins: *Pipeline Started* :rocket:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Branch:* master\n*Started by:* admin\n*Build URL:* ${BUILD_URL}")
        }
      }
    }
    
    stage('Checkout') {
      steps {
        echo "✅ Repository already checked out by Jenkins"
      }
    }
    
    stage('Build and Test') {
      steps {
        sh 'ls -ltr'
        sh 'cd spring-boot-app && mvn clean package'
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *Build and Test Completed* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* SUCCESS :tada:\n*Artifact:* spring-boot-web.jar created\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Build and Test Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Static Code Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonarqube', variable: 'SONAR_AUTH_TOKEN')]) {
          sh 'cd spring-boot-app && mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=${SONAR_URL}'
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *SonarQube Analysis Completed* :chart_with_upwards_trend:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* SUCCESS :tada:\n*SonarQube Dashboard:* ${SONAR_URL}/dashboard?id=com.abhishek%3Aspring-boot-demo\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *SonarQube Analysis Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Build and Push Docker Image') {
      environment {
        REGISTRY_CREDENTIALS = credentials('docker-hub')
      }
      steps {
        script {
          sh 'cd spring-boot-app && docker build -t ${DOCKER_IMAGE} .'
          sh 'echo $REGISTRY_CREDENTIALS_PSW | docker login -u $REGISTRY_CREDENTIALS_USR --password-stdin'
          sh 'docker push ${DOCKER_IMAGE}'
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":docker: *Docker Image Built & Pushed Successfully* :ship:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Push Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Registry:* Docker Hub\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Build/Push Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Push Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Update Deployment File') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'github', passwordVariable: 'GITHUB_TOKEN', usernameVariable: 'GITHUB_USERNAME')]) {
          sh '''
            git config user.email "khaledJenkins@gmail.com"
            git config user.name "Jenkins-user"
            git checkout master
            BUILD_NUMBER=${BUILD_NUMBER}
            sed -i "s/replaceImageTag/${BUILD_NUMBER}/g" spring-boot-app-manifests/deployment.yml
            
            if ! git diff --quiet spring-boot-app-manifests/deployment.yml; then
              git add spring-boot-app-manifests/deployment.yml
              git commit -m "Update deployment image to version ${BUILD_NUMBER}"
              git push https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:master
              echo "✅ Deployment file updated and pushed to GitHub"
            else
              echo "ℹ️ No changes to commit - deployment file already up to date"
            fi
          '''
        }
      }
    }
  }
  
  post {
    success {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "🎉 =============================================="
        echo "🎉 PIPELINE COMPLETED SUCCESSFULLY!"
        echo "🎉 Job: ${JOB_NAME}"
        echo "🎉 Build: #${BUILD_NUMBER}" 
        echo "🎉 Duration: ${duration}"
        echo "🎉 Docker Image: ${DOCKER_IMAGE}"
        echo "🎉 Deployment: Updated to version ${BUILD_NUMBER}"
        echo "🎉 Build URL: ${BUILD_URL}"
        echo "🎉 Console: ${BUILD_URL}console"
        echo "🎉 =============================================="
        
        sendSlackNotification('good', ":jenkins: *Pipeline Completed Successfully* :tada:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* SUCCESS :white_check_mark:\n*Duration:* ${duration}\n*Docker Image:* ${DOCKER_IMAGE}\n*Deployment:* Updated to version ${BUILD_NUMBER}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    failure {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "❌ =============================================="
        echo "❌ PIPELINE FAILED!"
        echo "❌ Job: ${JOB_NAME}"
        echo "❌ Build: #${BUILD_NUMBER}"
        echo "❌ Duration: ${duration}"
        echo "❌ Failed Stage: ${env.STAGE_NAME ?: 'Unknown'}"
        echo "❌ Build URL: ${BUILD_URL}"
        echo "❌ Console: ${BUILD_URL}console"
        echo "❌ Please check the logs for more details"
        echo "❌ =============================================="
        
        sendSlackNotification('danger', ":jenkins: *Pipeline Failed* :x:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* FAILED :red_circle:\n*Duration:* ${duration}\n*Failed Stage:* ${env.STAGE_NAME ?: 'Unknown'}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console\n*Please check the logs for more details* :point_up:")
      }
    }
    unstable {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Unstable* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* UNSTABLE :yellow_circle:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    aborted {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Aborted* :stop_sign:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* ABORTED :octagonal_sign:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
  }
}

// BULLETPROOF Slack notification function
def sendSlackNotification(String color, String message) {
  if (env.ENABLE_SLACK != 'true') {
    echo "📝 Slack disabled. Message: ${message}"
    return
  }
  
  echo "📧 Sending Slack notification to ${env.SLACK_CHANNEL}..."
  
  // Method 1: Try Jenkins global Slack configuration
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message
    )
    echo "✅ SUCCESS: Slack sent via global configuration"
    return
  } catch (Exception e1) {
    echo "⚠️ Method 1 failed: ${e1.getMessage()}"
  }
  
  // Method 2: Try with team domain
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message,
      teamDomain: 'work'
    )
    echo "✅ SUCCESS: Slack sent via team domain"
    return
  } catch (Exception e2) {
    echo "⚠️ Method 2 failed: ${e2.getMessage()}"
  }
  
  // Method 3: Try webhook approach (if configured)
  try {
    sh """
      curl -X POST -H 'Content-type: application/json' \
      --data '{"channel":"${env.SLACK_CHANNEL}","text":"${message}","username":"Jenkins","icon_emoji":":jenkins:"}' \
      \${SLACK_WEBHOOK_URL:-"https://hooks.slack.com/services/YOUR/WEBHOOK/URL"}
    """
    echo "✅ SUCCESS: Slack sent via webhook"
    return
  } catch (Exception e3) {
    echo "⚠️ Method 3 failed: ${e3.getMessage()}"
  }
  
  // Fallback: Beautiful console display
  echo ""
  echo "📧 =============== SLACK NOTIFICATION ==============="
  echo "📧 Channel: ${env.SLACK_CHANNEL} (work.slack.com)"
  echo "📧 Status: ${color == 'good' ? 'SUCCESS ✅' : color == 'danger' ? 'FAILED ❌' : 'INFO ℹ️'}"
  echo "📧 Message:"
  message.split('\n').each { line ->
    echo "📧   ${line}"
  }
  echo "📧 ================================================="
  echo "💡 To enable actual Slack notifications:"
  echo "💡 1. Configure Slack in Jenkins Global Settings"
  echo "💡 2. Or set SLACK_WEBHOOK_URL environment variable"
  echo "💡 3. Verify Jenkins has 'Slack Notification' plugin installed"
  echo ""
}
