pipeline {
  agent any
  tools {
    maven 'maven'
  }
  environment {
    SLACK_CHANNEL = '#devops'
    ENABLE_SLACK = 'true'
    DOCKER_IMAGE = "khaledhawil/java-cicd:${BUILD_NUMBER}"
    GIT_REPO_NAME = "Java-app-CI-CD-with-GitOps"
    GIT_USER_NAME = "khaledhawil"
    SONAR_URL = "http://sonarqube:9000"
    // Trivy configuration
    TRIVY_NO_PROGRESS = "true"
    TRIVY_CACHE_DIR = "/tmp/trivy-cache"
  }
  
  stages {
    stage('Pipeline Started') {
      steps {
        script {
          echo "ðŸš€ =============================================="
          echo "ðŸš€ Starting CI/CD Pipeline for ${JOB_NAME} #${BUILD_NUMBER}"
          echo "ðŸš€ Repository: ${env.GIT_REPO_NAME}"
          echo "ðŸš€ Branch: master"
          echo "ðŸš€ Build URL: ${BUILD_URL}"
          echo "ðŸš€ =============================================="
          
          sendSlackNotification('good', ":jenkins: *Pipeline Started* :rocket:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Branch:* master\n*Started by:* admin\n*Build URL:* ${BUILD_URL}")
        }
      }
    }
    
    stage('Checkout') {
      steps {
        echo "âœ… Repository already checked out by Jenkins"
      }
    }
    
    stage('Build and Test') {
      steps {
        sh 'ls -ltr'
        sh 'cd spring-boot-app && mvn clean package'
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":white_check_mark: *Build and Test Completed* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* SUCCESS :tada:\n*Artifact:* spring-boot-web.jar created\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Build and Test Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build and Test\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Static Code Analysis') {
      steps {
        withCredentials([string(credentialsId: 'sonarqube', variable: 'SONAR_AUTH_TOKEN')]) {
          script {
            sh 'cd spring-boot-app && mvn sonar:sonar -Dsonar.login=$SONAR_AUTH_TOKEN -Dsonar.host.url=${SONAR_URL}'
            
            // Wait for SonarQube to process results
            sleep(time: 10, unit: 'SECONDS')
            
            // Create reports directory and fetch SonarQube metrics
            sh '''
              mkdir -p sonar-reports
              echo "ðŸ” Fetching SonarQube analysis results..."
              
              PROJECT_KEY="com.abhishek:spring-boot-demo"
              
              # Get quality gate status
              curl -s -u ${SONAR_AUTH_TOKEN}: "${SONAR_URL}/api/qualitygates/project_status?projectKey=${PROJECT_KEY}" > sonar-reports/quality-gate.json
              
              # Get measures (bugs, vulnerabilities, code smells, coverage)
              curl -s -u ${SONAR_AUTH_TOKEN}: "${SONAR_URL}/api/measures/component?component=${PROJECT_KEY}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,ncloc" > sonar-reports/measures.json
              
              # Get issues by severity
              curl -s -u ${SONAR_AUTH_TOKEN}: "${SONAR_URL}/api/issues/search?componentKeys=${PROJECT_KEY}&facets=severities&ps=1" > sonar-reports/issues.json
              
              echo "ðŸ“Š Processing SonarQube results..."
              
              # Parse results and create summary
              if command -v jq >/dev/null 2>&1; then
                # Parse quality gate
                QUALITY_GATE=$(jq -r '.projectStatus.status // "UNKNOWN"' sonar-reports/quality-gate.json 2>/dev/null || echo "UNKNOWN")
                
                # Parse measures
                BUGS=$(jq -r '.component.measures[]? | select(.metric=="bugs") | .value // "0"' sonar-reports/measures.json 2>/dev/null || echo "0")
                VULNERABILITIES=$(jq -r '.component.measures[]? | select(.metric=="vulnerabilities") | .value // "0"' sonar-reports/measures.json 2>/dev/null || echo "0")
                CODE_SMELLS=$(jq -r '.component.measures[]? | select(.metric=="code_smells") | .value // "0"' sonar-reports/measures.json 2>/dev/null || echo "0")
                COVERAGE=$(jq -r '.component.measures[]? | select(.metric=="coverage") | .value // "N/A"' sonar-reports/measures.json 2>/dev/null || echo "N/A")
                
                # Parse severity counts
                BLOCKER=$(jq -r '.facets[]? | select(.property=="severities") | .values[]? | select(.val=="BLOCKER") | .count // 0' sonar-reports/issues.json 2>/dev/null || echo "0")
                CRITICAL=$(jq -r '.facets[]? | select(.property=="severities") | .values[]? | select(.val=="CRITICAL") | .count // 0' sonar-reports/issues.json 2>/dev/null || echo "0")
                MAJOR=$(jq -r '.facets[]? | select(.property=="severities") | .values[]? | select(.val=="MAJOR") | .count // 0' sonar-reports/issues.json 2>/dev/null || echo "0")
              else
                echo "âš ï¸ jq not available, using default values"
                QUALITY_GATE="UNKNOWN"
                BUGS="0"
                VULNERABILITIES="0"
                CODE_SMELLS="0"
                COVERAGE="N/A"
                BLOCKER="0"
                CRITICAL="0"
                MAJOR="0"
              fi
              
              # Display results
              echo ""
              echo "ðŸ“Š SONARQUBE ANALYSIS RESULTS:"
              echo "=============================================="
              echo "ðŸŽ¯ Quality Gate: $QUALITY_GATE"
              echo "ðŸ› Bugs: $BUGS"
              echo "ðŸ”’ Security Vulnerabilities: $VULNERABILITIES"
              echo "ðŸ”§ Code Smells: $CODE_SMELLS"
              echo "ðŸ“ˆ Test Coverage: $COVERAGE%"
              echo ""
              echo "ï¿½ Critical Issues:"
              echo "  ðŸ”´ Blocker: $BLOCKER"
              echo "  ðŸŸ  Critical: $CRITICAL"
              echo "  ðŸŸ¡ Major: $MAJOR"
              echo "=============================================="
              
              # Save results for Slack notification
              echo "$QUALITY_GATE" > sonar-reports/quality_gate.txt
              echo "$BUGS" > sonar-reports/bugs.txt
              echo "$VULNERABILITIES" > sonar-reports/vulnerabilities.txt
              echo "$CODE_SMELLS" > sonar-reports/code_smells.txt
              echo "$COVERAGE" > sonar-reports/coverage.txt
              echo "$BLOCKER" > sonar-reports/blocker.txt
              echo "$CRITICAL" > sonar-reports/critical.txt
              echo "$MAJOR" > sonar-reports/major.txt
            '''
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'sonar-reports/**', allowEmptyArchive: true
        }
        success {
          script {
            // Read SonarQube results
            def qualityGate = readFile('sonar-reports/quality_gate.txt').trim()
            def bugs = readFile('sonar-reports/bugs.txt').trim()
            def vulnerabilities = readFile('sonar-reports/vulnerabilities.txt').trim()
            def codeSmells = readFile('sonar-reports/code_smells.txt').trim()
            def coverage = readFile('sonar-reports/coverage.txt').trim()
            def blocker = readFile('sonar-reports/blocker.txt').trim()
            def critical = readFile('sonar-reports/critical.txt').trim()
            def major = readFile('sonar-reports/major.txt').trim()
            
            // Determine notification status
            def statusColor = 'good'
            def statusIcon = ':white_check_mark:'
            def reviewStatus = 'PASSED'
            
            if (qualityGate != 'OK') {
              statusColor = 'warning'
              statusIcon = ':warning:'
              reviewStatus = 'REVIEW REQUIRED'
            }
            
            if (blocker.isInteger() && blocker.toInteger() > 0 || critical.isInteger() && critical.toInteger() > 0) {
              statusColor = 'danger'
              statusIcon = ':x:'
              reviewStatus = 'ACTION REQUIRED'
            }
            
            def sonarMessage = """${statusIcon} *SonarQube Analysis Completed* :chart_with_upwards_trend:
*Job:* ${JOB_NAME}
*Build:* #${BUILD_NUMBER}
*Stage:* Static Code Analysis
*Status:* ${reviewStatus} ${statusIcon}

*Quality Gate:* ${qualityGate == 'OK' ? ':white_check_mark: PASSED' : ':x: FAILED'}

*ðŸ“Š Code Quality Summary:*
:bug: Bugs: ${bugs}
:lock: Security Vulnerabilities: ${vulnerabilities}
:wrench: Code Smells: ${codeSmells}
:chart_with_upwards_trend: Test Coverage: ${coverage}%

*ðŸš¨ Critical Issues:*
:red_circle: Blocker: ${blocker}
:large_orange_circle: Critical: ${critical}
:yellow_circle: Major: ${major}

*Review Status:* ${reviewStatus}
*SonarQube Dashboard:* ${SONAR_URL}/dashboard?id=com.abhishek%3Aspring-boot-demo
*Build Details:* ${BUILD_URL}"""

            sendSlackNotification(statusColor, sonarMessage)
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *SonarQube Analysis Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Static Code Analysis\n*Status:* FAILED :x:\n*Issue:* SonarQube analysis could not complete\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Build Docker Image') {
      steps {
        script {
          sh 'cd spring-boot-app && docker build -t ${DOCKER_IMAGE} .'
          echo "âœ… Docker image built successfully: ${DOCKER_IMAGE}"
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":docker: *Docker Image Built Successfully* :hammer_and_wrench:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Image Build Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Build Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Security Scan with Trivy') {
      steps {
        script {          
          // Update Trivy database
          sh 'trivy --version && trivy image --download-db-only'
          
          // Scan the Docker image with improved timeout and error handling
          sh """
            echo "ðŸ” =============================================="
            echo "ðŸ” Starting Trivy Security Scan"
            echo "ðŸ” Image: ${DOCKER_IMAGE}"
            echo "ðŸ” =============================================="
            
            # Create reports directory
            mkdir -p trivy-reports

            # Run Trivy scan with increased timeout
            echo "ðŸ” Running detailed security scan (this may take a few minutes)..."
            trivy image --timeout 15m --scanners vuln --format json --output trivy-reports/trivy-report.json ${DOCKER_IMAGE} || echo "âš ï¸ JSON scan encountered issues but continuing..."
            
            # Generate table report with shorter timeout  
            trivy image --timeout 5m --scanners vuln --format table --output trivy-reports/trivy-report.txt ${DOCKER_IMAGE} || echo "âš ï¸ Table report timed out, using JSON report only"
            
            # Display scan results
            echo ""
            echo "ðŸ“Š TRIVY SECURITY SCAN RESULTS:"
            echo "=============================================="
            
            if [ -f "trivy-reports/trivy-report.txt" ] && [ -s "trivy-reports/trivy-report.txt" ]; then
              echo "âœ… Displaying first 30 lines of scan results:"
              head -30 trivy-reports/trivy-report.txt
              echo ""
              echo "(Report truncated for display - full report in Jenkins artifacts)"
            else
              echo "âš ï¸ Table report not available, checking JSON report status..."
              if [ -f "trivy-reports/trivy-report.json" ]; then
                echo "âœ… JSON report generated - vulnerabilities will be counted"
              else
                echo "âŒ No scan reports generated successfully"
              fi
            fi
            echo "=============================================="
            
            # Count vulnerabilities with fallback methods
            CRITICAL_VULNS=0
            HIGH_VULNS=0
            
            if command -v jq >/dev/null 2>&1 && [ -f "trivy-reports/trivy-report.json" ]; then
              echo "ðŸ” Analyzing vulnerabilities with jq..."
              CRITICAL_VULNS=\$(jq -r 'if .Results then [.Results[]?.Vulnerabilities[]? // empty] | map(select(.Severity == "CRITICAL")) | length else 0 end' trivy-reports/trivy-report.json 2>/dev/null || echo "0")
              HIGH_VULNS=\$(jq -r 'if .Results then [.Results[]?.Vulnerabilities[]? // empty] | map(select(.Severity == "HIGH")) | length else 0 end' trivy-reports/trivy-report.json 2>/dev/null || echo "0")
            else
              echo "ðŸ” Using grep-based counting (fallback method)..."
              if [ -f "trivy-reports/trivy-report.txt" ]; then
                CRITICAL_VULNS=\$(grep -c "CRITICAL" trivy-reports/trivy-report.txt 2>/dev/null || echo "0")
                HIGH_VULNS=\$(grep -c "HIGH" trivy-reports/trivy-report.txt 2>/dev/null || echo "0")
              fi
            fi
            
            echo ""
            echo "ðŸ“ˆ VULNERABILITY SUMMARY:"
            echo "Critical: \$CRITICAL_VULNS"
            echo "High: \$HIGH_VULNS"
            echo "Status: \$([ \$CRITICAL_VULNS -eq 0 ] && echo 'âœ… No Critical Issues' || echo 'âš ï¸ Review Required')"
            echo ""
            
            # Store counts for post actions
            echo \$CRITICAL_VULNS > trivy-reports/critical-count.txt
            echo \$HIGH_VULNS > trivy-reports/high-count.txt
            
            # Create summary report
            echo "Creating scan summary..."
            cat > trivy-reports/summary.txt << 'EOL'
Trivy Security Scan Summary
===========================
EOL
            echo "Image: ${DOCKER_IMAGE}" >> trivy-reports/summary.txt
            echo "Scan Date: \$(date)" >> trivy-reports/summary.txt
            echo "Critical Vulnerabilities: \$CRITICAL_VULNS" >> trivy-reports/summary.txt
            echo "High Vulnerabilities: \$HIGH_VULNS" >> trivy-reports/summary.txt
            echo "Status: \$([ \$CRITICAL_VULNS -eq 0 ] && echo 'PASSED âœ…' || echo 'REVIEW REQUIRED âš ï¸')" >> trivy-reports/summary.txt
            
            echo ""
            echo "ðŸ“‹ SCAN SUMMARY:"
            cat trivy-reports/summary.txt
          """
        }
      }
      post {
        always {
          // Archive the Trivy reports
          archiveArtifacts artifacts: 'trivy-reports/*', allowEmptyArchive: true
        }
        success {
          script {
            def criticalCount = readFile('trivy-reports/critical-count.txt').trim()
            def highCount = readFile('trivy-reports/high-count.txt').trim()
            
            // Determine security status and appropriate color
            def securityColor = 'good'
            def securityStatus = ':white_check_mark: SECURE'
            def securityIcon = ':shield:'
            def actionRequired = ''
            
            if (criticalCount.toInteger() > 0) {
              securityColor = 'danger'
              securityStatus = ':rotating_light: CRITICAL VULNERABILITIES FOUND'
              securityIcon = ':warning:'
              actionRequired = '\n:exclamation: *IMMEDIATE ACTION REQUIRED*\n:point_right: Review critical vulnerabilities before production deployment'
            } else if (highCount.toInteger() > 0) {
              securityColor = 'warning'
              securityStatus = ':yellow_circle: HIGH VULNERABILITIES DETECTED'
              securityIcon = ':mag:'
              actionRequired = '\n:warning: *REVIEW RECOMMENDED*\n:point_right: Consider updating dependencies to fix high-severity issues'
            }
            
            def vulnerabilitySummary = ''
            if (criticalCount.toInteger() > 0 || highCount.toInteger() > 0) {
              vulnerabilitySummary = "\n\n:bar_chart: *Vulnerability Breakdown:*"
              if (criticalCount.toInteger() > 0) {
                vulnerabilitySummary += "\n:red_circle: Critical: ${criticalCount}"
              }
              if (highCount.toInteger() > 0) {
                vulnerabilitySummary += "\n:orange_circle: High: ${highCount}"
              }
              vulnerabilitySummary += "\n:blue_circle: Medium & Low: Additional issues detected"
              vulnerabilitySummary += "\n\n:clipboard: *Full Report:* ${BUILD_URL}artifact/trivy-reports/"
            }
            
            sendSlackNotification(securityColor, "${securityIcon} *Trivy Security Scan Complete* ${securityIcon}\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Image:* ${DOCKER_IMAGE}\n*Status:* ${securityStatus}${vulnerabilitySummary}${actionRequired}\n\n:link: *Build Details:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Trivy Security Scan Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Image:* ${DOCKER_IMAGE}\n*Status:* SCAN FAILED :red_circle:\n*Issue:* Security scanning could not complete\n:point_right: Check Jenkins logs for scan errors\n\n:link: *Console:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Push Docker Image') {
      environment {
        REGISTRY_CREDENTIALS = credentials('docker-hub')
      }
      steps {
        script {
          sh 'echo $REGISTRY_CREDENTIALS_PSW | docker login -u $REGISTRY_CREDENTIALS_USR --password-stdin'
          sh 'docker push ${DOCKER_IMAGE}'
          echo "âœ… Docker image pushed successfully to Docker Hub"
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":rocket: *Docker Image Pushed Successfully* :ship:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Push Docker Image\n*Status:* SUCCESS :white_check_mark:\n*Docker Image:* ${DOCKER_IMAGE}\n*Registry:* Docker Hub\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Docker Push Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Push Docker Image\n*Status:* FAILED :x:\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
    
    stage('Update Deployment File') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'github', passwordVariable: 'GITHUB_TOKEN', usernameVariable: 'GITHUB_USERNAME')]) {
          sh '''
            echo "ðŸ”„ Updating deployment file with new image version..."
            git config user.email "khaledJenkins@gmail.com"
            git config user.name "Jenkins-user"
            git checkout master
            
            echo "ðŸ“ Current deployment file content:"
            cat spring-boot-app-manifests/deployment.yml
            
            # Update the image tag
            BUILD_NUMBER=${BUILD_NUMBER}
            echo "ðŸ·ï¸ Updating image tag to version: ${BUILD_NUMBER}"
            
            # Replace both placeholder and any existing version
            sed -i "s|image: khaledhawil/java-cicd:.*|image: khaledhawil/java-cicd:${BUILD_NUMBER}|g" spring-boot-app-manifests/deployment.yml
            
            echo "ðŸ“ Updated deployment file content:"
            cat spring-boot-app-manifests/deployment.yml
            
            # Check if file was actually modified
            if ! git diff --quiet spring-boot-app-manifests/deployment.yml; then
              echo "âœ… Changes detected in deployment file"
              git add spring-boot-app-manifests/deployment.yml
              git commit -m "ðŸš€ Update deployment image to version ${BUILD_NUMBER} [CI/CD]"
              
              echo "ðŸ”„ Pushing changes to GitHub..."
              git push https://${GITHUB_TOKEN}@github.com/${GIT_USER_NAME}/${GIT_REPO_NAME} HEAD:master
              
              echo "âœ… Deployment file successfully updated and pushed to GitHub"
              echo "ðŸŽ¯ Image updated to: khaledhawil/java-cicd:${BUILD_NUMBER}"
            else
              echo "â„¹ï¸ No changes detected - deployment file may already be up to date"
              echo "ðŸ” Current image in deployment file:"
              grep "image:" spring-boot-app-manifests/deployment.yml
            fi
          '''
        }
      }
      post {
        success {
          script {
            sendSlackNotification('good', ":kubernetes: *Deployment Updated Successfully* :gear:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Update Deployment File\n*Status:* SUCCESS :white_check_mark:\n*New Image:* khaledhawil/java-cicd:${BUILD_NUMBER}\n*GitOps:* Deployment manifest updated in repository\n*Build URL:* ${BUILD_URL}")
          }
        }
        failure {
          script {
            sendSlackNotification('danger', ":x: *Deployment Update Failed* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Stage:* Update Deployment File\n*Status:* FAILED :x:\n*Issue:* Could not update Kubernetes deployment manifest\n*Build URL:* ${BUILD_URL}console")
          }
        }
      }
    }
  }
  
  post {
    success {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "ðŸŽ‰ =============================================="
        echo "ðŸŽ‰ PIPELINE COMPLETED SUCCESSFULLY!"
        echo "ðŸŽ‰ Job: ${JOB_NAME}"
        echo "ðŸŽ‰ Build: #${BUILD_NUMBER}" 
        echo "ðŸŽ‰ Duration: ${duration}"
        echo "ðŸŽ‰ Docker Image: ${DOCKER_IMAGE}"
        echo "ðŸŽ‰ Deployment: Updated to version ${BUILD_NUMBER}"
        echo "ðŸŽ‰ Build URL: ${BUILD_URL}"
        echo "ðŸŽ‰ Console: ${BUILD_URL}console"
        echo "ðŸŽ‰ =============================================="
        
        sendSlackNotification('good', ":jenkins: *Pipeline Completed Successfully* :tada:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* SUCCESS :white_check_mark:\n*Duration:* ${duration}\n*Docker Image:* ${DOCKER_IMAGE}\n*Deployment:* Updated to version ${BUILD_NUMBER}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    failure {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        echo "âŒ =============================================="
        echo "âŒ PIPELINE FAILED!"
        echo "âŒ Job: ${JOB_NAME}"
        echo "âŒ Build: #${BUILD_NUMBER}"
        echo "âŒ Duration: ${duration}"
        echo "âŒ Failed Stage: ${env.STAGE_NAME ?: 'Unknown'}"
        echo "âŒ Build URL: ${BUILD_URL}"
        echo "âŒ Console: ${BUILD_URL}console"
        echo "âŒ Please check the logs for more details"
        echo "âŒ =============================================="
        
        sendSlackNotification('danger', ":jenkins: *Pipeline Failed* :x:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* FAILED :red_circle:\n*Duration:* ${duration}\n*Failed Stage:* ${env.STAGE_NAME ?: 'Unknown'}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console\n*Please check the logs for more details* :point_up:")
      }
    }
    unstable {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Unstable* :warning:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* UNSTABLE :yellow_circle:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
    aborted {
      script {
        def duration = currentBuild.durationString.replace(' and counting', '')
        sendSlackNotification('warning', ":jenkins: *Pipeline Aborted* :stop_sign:\n*Job:* ${JOB_NAME}\n*Build:* #${BUILD_NUMBER}\n*Status:* ABORTED :octagonal_sign:\n*Duration:* ${duration}\n*Build URL:* ${BUILD_URL}\n*Console:* ${BUILD_URL}console")
      }
    }
  }
}

// BULLETPROOF Slack notification function
def sendSlackNotification(String color, String message) {
  if (env.ENABLE_SLACK != 'true') {
    echo "ðŸ“ Slack disabled. Message: ${message}"
    return
  }
  
  echo "ðŸ“§ Sending Slack notification to ${env.SLACK_CHANNEL}..."
  
  // Method 1: Try Jenkins global Slack configuration
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message
    )
    echo "âœ… SUCCESS: Slack sent via global configuration"
    return
  } catch (Exception e1) {
    echo "âš ï¸ Method 1 failed: ${e1.getMessage()}"
  }
  
  // Method 2: Try with team domain
  try {
    slackSend(
      channel: env.SLACK_CHANNEL,
      color: color,
      message: message,
      teamDomain: 'work'
    )
    echo "âœ… SUCCESS: Slack sent via team domain"
    return
  } catch (Exception e2) {
    echo "âš ï¸ Method 2 failed: ${e2.getMessage()}"
  }
  
  // Method 3: Try webhook approach (if configured)
  try {
    sh """
      curl -X POST -H 'Content-type: application/json' \
      --data '{"channel":"${env.SLACK_CHANNEL}","text":"${message}","username":"Jenkins","icon_emoji":":jenkins:"}' \
      \${SLACK_WEBHOOK_URL:-"https://hooks.slack.com/services/YOUR/WEBHOOK/URL"}
    """
    echo "âœ… SUCCESS: Slack sent via webhook"
    return
  } catch (Exception e3) {
    echo "âš ï¸ Method 3 failed: ${e3.getMessage()}"
  }
  
  // Fallback: Beautiful console display
  echo ""
  echo "ðŸ“§ =============== SLACK NOTIFICATION ==============="
  echo "ðŸ“§ Channel: ${env.SLACK_CHANNEL} (work.slack.com)"
  echo "ðŸ“§ Status: ${color == 'good' ? 'SUCCESS âœ…' : color == 'danger' ? 'FAILED âŒ' : 'INFO â„¹ï¸'}"
  echo "ðŸ“§ Message:"
  message.split('\n').each { line ->
    echo "ðŸ“§   ${line}"
  }
  echo "ðŸ“§ ================================================="
  echo "ðŸ’¡ To enable actual Slack notifications:"
  echo "ðŸ’¡ 1. Configure Slack in Jenkins Global Settings"
  echo "ðŸ’¡ 2. Or set SLACK_WEBHOOK_URL environment variable"
  echo "ðŸ’¡ 3. Verify Jenkins has 'Slack Notification' plugin installed"
  echo ""
}
